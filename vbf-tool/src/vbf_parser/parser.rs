extern crate json;
extern crate sha2;

use std::{fs, io};
use std::io::prelude::*;
use sha2::{Sha256, Digest};
//CRC_16_IBM_3740 -> CCITT,AUTOSAR
use crc::{Crc, CRC_32_ISCSI, CRC_16_IBM_3740};
use std::mem::transmute;
const _HEADER: &str = r#"
header {
    //**********************************************************
    //*
    //*                  Nonexistent Car Corporation
    //*
    //*     This file is generated by VBF CONVERT ver. beta 1.0
    //*
    //*                        DO NOT EDIT !
    //*
    //**********************************************************

"#;
pub struct VbfFt{
    status:StatusT,
    script:ScriptsT,
}

impl VbfFt {
    pub fn new(vbb_path: &str) -> io::Result<()> {
        let vbb_json = fs::read_to_string(vbb_path).unwrap();
        let vbb_parsed = json::parse(&vbb_json).unwrap();
        let vbf_inst = VbfFt{
            status: StatusT::Init,
            script: ScriptsT{
                source_file: Item {
                    description: String::from("blahblah"),
                    value: ValueT::Literal(String::from(vbb_parsed["VBF1"]["SourceFile"].as_str().unwrap())),
                },
                target_file: Item { 
                    description: String::from("blahblah"), 
                    value: ValueT::Literal(String::from(vbb_parsed["VBF1"]["TargetFile"].as_str().unwrap())), 
                },
                vbf_version: Item { 
                    description: String::from("blahblah"), 
                    value: ValueT::Literal( String::from(vbb_parsed["VBF1"]["VBFVersion"].as_str().unwrap())), 
                },
                sw_type: Item { 
                    description: String::from("software part type: Executable"), 
                    value: ValueT::Literal( String::from(vbb_parsed["VBF1"]["SwType"].as_str().unwrap())), 
                },
                sw_part_nmu: Item { 
                    description: String::from("software part number:"), 
                    value: ValueT::Literal( String::from(vbb_parsed["VBF1"]["SwPartNum"].as_str().unwrap())), 
                },
                ecu_addr: Item { 
                    description: String::from("ECU Address:"), 
                    value: ValueT::Literal( String::from(vbb_parsed["VBF1"]["ECUaddr"].as_str().unwrap())), 
                },
                sw_version: Item { 
                    description: String::from("Software Version:"), 
                    value: ValueT::Literal( String::from(vbb_parsed["VBF1"]["SwVersion"].as_str().unwrap())), 
                },
                create_vbt: Item { 
                    description: String::from("If enable VBT"), 
                    value: ValueT::Toggle(vbb_parsed["VBF1"]["CreateVerificationBlock"].as_bool().unwrap()), 
                },
                vbt_addr: Item { 
                    description: String::from("Start address of the VBT"), 
                    value: ValueT::Literal( String::from(vbb_parsed["VBF1"]["VerificationBlockStartAddr"].as_str().unwrap())), 
                },
                compressed: Item { 
                    description: String::from("If enable compress fea:"), 
                    value: ValueT::Toggle(vbb_parsed["VBF1"]["Compressed"].as_bool().unwrap()), 
                },
                sort: Item { 
                    description: String::from("Sorted"), 
                    value: ValueT::Toggle(vbb_parsed["VBF1"]["Sort"].as_bool().unwrap()), 
                },
                group: Item { 
                    description: String::from("Grouped"), 
                    value: ValueT::Toggle(vbb_parsed["VBF1"]["Group"].as_bool().unwrap()), 
                },
            },
        };
        // calculate bin file hash256
        let bin_file_path = vbf_inst.script.source_file.value.literal().unwrap();
        let mut bin_file = fs::File::open(bin_file_path).unwrap();
        let mut hasher = Sha256::new();
        let n = io::copy(&mut bin_file, &mut hasher).unwrap();
        let hash = hasher.finalize();
        println!("binary hash({:x?}) :{:x?}", n,hash);

        // try to create new vbf files
        let target_file_path = vbf_inst.script.target_file.value.literal().unwrap();
        let mut file_w = fs::File::create(target_file_path).unwrap();
        file_w.write_all(vbf_inst.script.vbf_version.value.literal().unwrap().as_bytes()).unwrap();
        file_w.write_all(b";\n").unwrap();
        file_w.write_all(_HEADER.as_bytes()).unwrap();

        // write trivial option parameters
        VbfFt::dump(&vbf_inst, &mut file_w).unwrap();

        // write all metadata to disk
        file_w.sync_all().unwrap();
        Ok(())
    }
    #[allow(dead_code)]
    pub fn print_info(&self) {
        println!("magic u8 : {:?}", self.status);
        println!("vbf_info : {:#?}", self.script);
    }
    pub fn dump(&self, fp: &mut fs::File) -> io::Result<()>{
        fp.write_fmt(format_args!("\t// {}\n", self.script.sw_part_nmu.description)).unwrap();
        fp.write_fmt(format_args!("\t   sw_part_number = \"{}\";\n\n", self.script.sw_part_nmu.value.literal().unwrap())).unwrap();

        fp.write_fmt(format_args!("\t// {}\n", self.script.sw_version.description)).unwrap();
        fp.write_fmt(format_args!("\t   sw_version = \"{}\";\n\n", self.script.sw_version.value.literal().unwrap())).unwrap();

        fp.write_fmt(format_args!("\t// {}\n", self.script.sw_type.description)).unwrap();
        fp.write_fmt(format_args!("\t   sw_part_type = {};\n\n", self.script.sw_type.value.literal().unwrap())).unwrap();

        fp.write_fmt(format_args!("\t// {}\n", self.script.ecu_addr.description)).unwrap();
        fp.write_fmt(format_args!("\t   ecu_address = {};\n\n", self.script.ecu_addr.value.literal().unwrap())).unwrap();
        
        // write crc
        let crc32_inst = Crc::<u32>::new(&CRC_32_ISCSI);
        let crc16_inst = Crc::<u16>::new(&CRC_16_IBM_3740);
        let mut bin_crc32 = crc32_inst.digest();
        let mut bin_crc16 = crc16_inst.digest();
        let mut bin_size:u32 = 0;
        // let path2 = Path::new("case3-calcrc");
        let mut f_bin = fs::File::open(self.script.source_file.value.literal().unwrap()).unwrap();
        // let mut file_size:usize = 0;
        let crc_v = loop {
            let mut buffer = [0;100];
            let n = f_bin.read(&mut buffer[..]).unwrap() as u32;
            bin_crc32.update(&buffer);
            bin_crc16.update(&buffer);
            bin_size += n;
            if n < 100 {
                break (bin_crc32.finalize(), bin_crc16.finalize())
            }
        };
        // file_checksum
        fp.write_fmt(format_args!("\tfile_checksum = 0x{:08X};\n", crc_v.0)).unwrap();
        fp.write_all(b"}").unwrap();
        
        // seek bin file to start 
        f_bin.seek(io::SeekFrom::Start(0)).unwrap();
        let start_address = 00000000_u32;
        let bytes: [u8; 4] = unsafe { transmute(start_address.to_be()) };
        fp.write_all(&bytes).unwrap();
        let bytes: [u8; 4] = unsafe { transmute(bin_size.to_be()) };
        fp.write_all(&bytes).unwrap();

        // write binary of bin to target file
        loop {
            let mut buffer = [0;100];
            let n = f_bin.read(&mut buffer[..]).unwrap();
            if n < 100 {
                fp.write(&buffer[..n]).unwrap();
                break;
            } else {
                fp.write_all(&buffer).unwrap();
            }
        };
        let bytes: [u8; 2] = unsafe { transmute(crc_v.1.to_be()) };
        fp.write_all(&bytes).unwrap();
        fp.sync_all().unwrap();
        println!("crc16:0x{:04X}", crc_v.1);
        println!("bin_size:0x{:0X}", bin_size);
        Ok(())
    }
}
#[derive(Debug)]
enum StatusT {
    Init,
    Uninit,
}
#[derive(Debug)]
struct ScriptsT {
    source_file: Item,//input bin file
    target_file: Item,//output vbf file
    vbf_version: Item,//vbf format version 
    sw_type: Item, //software type,
    sw_part_nmu: Item,//software partnumber
    ecu_addr: Item,//ecu address
    sw_version: Item,//software version
    create_vbt: Item,//if create verification block table
    vbt_addr: Item,//address of vbt
    compressed: Item,//if compress input bin file
    sort: Item,//tbd
    group: Item,//tbd
}
#[derive(Debug)]
struct Item {
    description: String,
    value:ValueT,
}
#[derive(Debug)]
enum ValueT {
    Literal(String),
    Toggle(bool),
}
impl ValueT {
    fn literal(&self) -> Option<String> {
        match self {
            ValueT::Literal(c) => Some(c.to_string()),
            _ => None,
        }
    }    
    fn toggle(&self) -> Option<bool> {
        match self {
            ValueT::Toggle(c) => Some(*c),
            _ => None,
        }
    }    
}

// fn get_crc()