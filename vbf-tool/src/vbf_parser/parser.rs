extern crate json;
extern crate sha2;

use std::{fs, io};
use std::io::prelude::*;
use sha2::{Sha256, Digest};

const _HEADER: &str = r#"
header {
    //**********************************************************
    //*
    //*                  Nonexistent Car Corporation
    //*
    //*     This file is generated by VBF CONVERT ver. beta1.0
    //*
    //*                        DO NOT EDIT !
    //*
    //**********************************************************
"#;
pub struct VbfFt{
    status:StatusT,
    script:ScriptsT,
}

impl VbfFt {
    pub fn new(vbb_path: &str) -> io::Result<()> {
        let vbb_json = fs::read_to_string(vbb_path).unwrap();
        let vbb_parsed = json::parse(&vbb_json).unwrap();
        let vbf_inst = VbfFt{
            status: StatusT::Init,
            script: ScriptsT{
                source_file: String::from(vbb_parsed["VBF1"]["SourceFile"].as_str().unwrap()),
                target_file: String::from(vbb_parsed["VBF1"]["TargetFile"].as_str().unwrap()),
                vbf_version: String::from(vbb_parsed["VBF1"]["VBFVersion"].as_str().unwrap()),
                sw_type: String::from(vbb_parsed["VBF1"]["SwType"].as_str().unwrap()),
                sw_part_nmu: String::from(vbb_parsed["VBF1"]["SwPartNum"].as_str().unwrap()),
                ecu_addr: String::from(vbb_parsed["VBF1"]["ECUaddr"].as_str().unwrap()),
                sw_version: String::from(vbb_parsed["VBF1"]["SwVersion"].as_str().unwrap()),
                create_vbt: vbb_parsed["VBF1"]["CreateVerificationBlock"].as_bool().unwrap(),
                vbt_addr: String::from(vbb_parsed["VBF1"]["VerificationBlockStartAddr"].as_str().unwrap()),
                compressed: vbb_parsed["VBF1"]["Compressed"].as_bool().unwrap(),
                sort: vbb_parsed["VBF1"]["Sort"].as_bool().unwrap(),
                group: vbb_parsed["VBF1"]["Group"].as_bool().unwrap(),
            },
        };
        // calculate bin file hash256
        let mut bin_file = fs::File::open(&vbf_inst.script.source_file).unwrap();
        let mut hasher = Sha256::new();
        let n = io::copy(&mut bin_file, &mut hasher).unwrap();
        let hash = hasher.finalize();
        println!("binary hash({:x?}) :{:x?}", n,hash);
        let mut file_w = fs::File::create(&vbf_inst.script.target_file).unwrap();
        file_w.write_all(vbf_inst.script.vbf_version.as_bytes()).unwrap();
        file_w.write_all(";".as_bytes()).unwrap();
        file_w.write_all(_HEADER.as_bytes()).unwrap();
        file_w.write_all("}".as_bytes()).unwrap();
        Ok(())
    }
    #[allow(dead_code)]
    pub fn print_info(&self) {
        println!("magic u8 : {:?}", self.status);
        println!("vbf_info : {:#?}", self.script);
    }
}
#[derive(Debug)]
enum StatusT {
    Init,
    Uninit,
}
#[derive(Debug)]
struct ScriptsT {
    source_file: String,//input bin file
    target_file: String,//output vbf file
    vbf_version: String,//vbf format version 
    sw_type: String, //software type,
    sw_part_nmu: String,//software partnumber
    ecu_addr: String,//ecu address
    sw_version: String,//software version
    create_vbt: bool,//if create verification block table
    vbt_addr: String,//address of vbt
    compressed: bool,//if compress input bin file
    sort: bool,//tbd
    group: bool,//tbd
}


// pub fn parser_test() {
//     println!("paser test");
// }

